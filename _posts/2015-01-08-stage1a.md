---
title: Chat Demo - Stage 1a - The server and client
layout: post
categories: chat_app
tags: node.js javascript websockets socket.io npm
---

Now that the folder structure for the Chat app is set up, we can start writing the client and server.

# The Server

I'm using the [Express](expressjs.com) framework to handle the web stuff in node.

## The index.js controller

chat.js
{: .listing-header}

{% highlight javascript %}

  {% include stage_1/chat.js %}

{% endhighlight  %}

### The HTTP server instance

The HTTP server is created with the line `require('http').Server`

`Server` is an alias to the createServer function and returns a new Server instance. The express app is set as the
request listener.

<div class="note" markdown='1'>
You have to create the server yourself and not just let Express do it for you implicitly, becuase you need the
Server instance to attach the websocket (see [below](#the-socketio-handler)).
</div>


### Static files

`app.use(serveStatic('public'));`

<div class="note" markdown='1'>
The `serveStatic` middleware will serve all files in the `public` folder to the '/' route.
i.e. asking for `/css/chat.js` in the browser will serve up the file in `public/css/chat.css`.

Usually, I'll use NginX to serve static files; this is fine for development
</div>

### Jade templates

`app.set('view engine','jade');`

The [Jade templating](jade-lang.com) language make writing HTML pages a lot cleaner and simpler.

The templates for the main chat page look like this


layout.jade
{: .listing-header}

{% highlight jade %}
    
    {% include stage_1/views/layout.jade %}

{% endhighlight %}

index.jade
{: .listing-header}

{% highlight jade %}

  {% include stage_1/views/index.jade %}
  
{% endhighlight %}


## The route definitions

The routes are pulled out and exported from the `lib/routes.js` file. This makes the main controller far
cleaner and more elegant. At this stage the `routes.js` file doesn't contain much:

routes.js
{: .listing-header}

{% highlight javascript %}

    {% include stage_1/lib/routes.js %}
    
{% endhighlight %}

## The socket.io handler

The code to handle websocket communication is really straightforward and illustrates the beauty of socket.io

socket.js
{: .listing-header}

{% highlight javascript %}

    {% include stage_1/lib/socket.js %}
    
{% endhighlight  %}

This little piece of code already provides enough usability for a simple chat app. Behind the scenes you get the following
    out of the box:

* Fallback to XHR or polling if WebSockets aren't supported
* Automatic reconnection
